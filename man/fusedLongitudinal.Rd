% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fused_longitudinal.R
\name{fusedLongitudinal}
\alias{fusedLongitudinal}
\title{interaction detection for longitudinal outcomes using fused lasso}
\usage{
fusedLongitudinal(x, y, trt, family = c("gaussian", "binomial", "coxph"),
  weights = NULL, type.measure = c("mse", "deviance", "class", "auc",
  "mae"), lambda = numeric(0), lasso.penalize = NULL, gamma = 1,
  nlambda = 100L, nfolds = 10L, foldid = NULL, boot = FALSE, B = 100L,
  boot.type = c("replacement", "mofn"), m.frac = 0.9, parallel = FALSE,
  abs.tol = 1e-05, rel.tol = 1e-05, maxit = 250, maxit.cv = 250,
  rho = NULL, ...)
}
\arguments{
\item{x}{list of design matrices; one for each point in time. If a matrix is given, the design matrix is assumed to
be constant over time
Each row is an observation, each column corresponds to a covariate}

\item{y}{list of numeric response vectors of length nobs(t); one element with a response vector for time t.}

\item{trt}{list of length equal to the number of time periods. each element of trt is a vector of treatment indicators}

\item{family}{"gaussian" for least squares problems, "binomial" for binary response.
"coxph" for time-to-event outcomes}

\item{weights}{observation weights}

\item{type.measure}{one of c("mse","deviance","class","auc","mae") to be used for cross validation}

\item{lambda}{tuning parameter values for lasso penalty}

\item{lasso.penalize}{list of length equal to the number of time periods. each element of lasso.penalize is a vector
of length equal to the number of variables in x[[t]] (design matrix at time t) with values either 0 or 1 where a 1
in the jth position indicates that the jth variable will be penalized with the lasso and 0 otherwise. Defaults to all
variables being penalized with the lasso.}

\item{gamma}{ratio of fused lasso to lasso tuning parameter}

\item{nlambda}{number of tuning parameter values - default is 100.}

\item{nfolds}{number of folds for cross validation. If given value 0, 1, or NULL, no cross validation will be performed}

\item{boot}{logical, whether or not to perform bootstrap for benefit confidence intervals. default is FALSE
for no bootstrap computation}

\item{B}{integer number of resamples for bootstrap - default is 100}

\item{parallel}{boolean indicator of whether or not to utilize parallel computation for cross validation}

\item{...}{other arguments to be passed to cv.fusedlasso}
}
\value{
An object with S3 class "fusedLongitudinal"
}
\description{
interaction detection for longitudinal outcomes using fused lasso
}
\examples{
set.seed(123)
nobs       <- 100
nobs.test  <- 1e5
nvars      <- 20
periods    <- 6
sd         <- 2

beta.nz <- rbind(c( 1,    1,    1,    1.5,  1.5,  1.5),
                 c(-1,   -1,   -1,   -0.5, -0.5, -0.5),
                 c( 1,    1,    1,   -1,   -1,   -1),
                 c( 1,    1,    1,    1,    1,    1),
                 c(-0.5, -0.5, -0.5, -0.5, -0.5, -0.5))

beta <- data.matrix(rbind(beta.nz, matrix(0, nvars - 5, periods)))

trt <- rbinom(nobs, 1, 0.5)
x   <- matrix(rnorm(nobs * nvars), ncol = nvars); colnames(x) <- paste0("V", 1:ncol(x))
y   <- x \%*\% (beta * 0.5) + (2 * trt - 1) * (x \%*\% beta) +
    matrix(rnorm(nobs * periods, sd = sd), ncol = periods)
y   <- apply(y, 2, function(yy) yy - (2 * trt - 1))

plot(x = NULL, xlim = c(1,6), ylim = range(y))
for (i in 1:nobs)
{
    lines(x = 1:6, y = y[i,], col = colors()[i+1])
}

x.list <- rep(list(x), periods)
y.list <- lapply(apply(y, 2, function(x) list(x) ), function(x) x[[1]])

fit <- fusedLongitudinal(x = x.list, y = y.list, trt = trt, gamma = c(0.05, 0.1, 1, 2, 5, 10))

round(matrix(fit$cv.models$best.cv.fit$beta, ncol = 6), 4)

bfit <- fusedLongitudinal(x = x.list, y = y.list,
                          trt = trt, gamma = c(0.05, 0.1, 1),
                          boot = TRUE, B = 50L)

lapply(bfit$boot.res, function(x) round(colMeans(x, na.rm = TRUE), 4) )
## bootstrap CI
CIs <- lapply(bfit$boot.res, function(x) apply(x, 2, function(xx)
     quantile(xx, probs = c(0.025, 0.975), na.rm = TRUE)) )

D <- lapply(1:periods, function(i) 1 * (drop(x.list[[i]] \%*\%  beta[,i]) > 0) )
res.vec <- numeric(11L)
names(res.vec) <- colnames(bfit$boot.res[[1]])
oracle.results <- rep(list(res.vec), periods)
for (t in 1:periods)
{
     y.cur <- y.list[[t]]
     D.cur <- D[[t]]
     weights.cur <- rep(1, length(y.cur))
     # Emprical average among all
     oracle.results[[t]][1] <- sum(y.cur * weights.cur) / sum(weights.cur)

     # Fit statistics among Trt=D
     sub.agree                <- trt == D.cur
     oracle.results[[t]][2] <- sum(y.cur[sub.agree] * weights.cur[sub.agree]) /
         sum(weights.cur[sub.agree])

     # Fit statistics among Trt!=D
     sub.disagree             <- trt != D.cur
     oracle.results[[t]][3] <- sum(y.cur[sub.disagree] * weights.cur[sub.disagree]) /
         sum(weights.cur[sub.disagree])

     # Fit statistics among Trt=D=1
     sub.11                   <- (trt == 1) & (D.cur == 1)
     oracle.results[[t]][4] <- sum(y.cur[sub.11] * weights.cur[sub.11]) /
         sum(weights.cur[sub.11])

     # Fit statistics among Trt=D=0
     sub.00                   <- (trt == 0) & (D.cur == 0)
     oracle.results[[t]][5] <- sum(y.cur[sub.00] * weights.cur[sub.00]) /
         sum(weights.cur[sub.00])

     # Fit statistics among Trt=0, D=1
     sub.01                   <- (trt == 0) & (D.cur == 1)
     oracle.results[[t]][6] <- sum(y.cur[sub.01] * weights.cur[sub.01]) /
         sum(weights.cur[sub.01])

     # Fit statistics among Trt=1, D=0
     sub.10                   <- (trt == 1) & (D.cur == 0)
     oracle.results[[t]][7] <- sum(y.cur[sub.10] * weights.cur[sub.10]) /
         sum(weights.cur[sub.10])

     # Fit statistics among D=1
     sub.x1                   <- (D.cur == 1)
     oracle.results[[t]][8] <- sum(y.cur[sub.x1] * weights.cur[sub.x1]) /
         sum(weights.cur[sub.x1])

     # Fit statistics among D=0
     sub.x0                   <- (D.cur == 0)
     oracle.results[[t]][9] <- sum(y.cur[sub.x0] * weights.cur[sub.x0]) /
         sum(weights.cur[sub.x0])

     # Fit statistics among Trt=1
     sub.1x                   <- (trt == 1)
     oracle.results[[t]][10] <- sum(y.cur[sub.1x] * weights.cur[sub.1x]) /
         sum(weights.cur[sub.1x])

     # Fit statistics among Trt=0
     sub.0x                   <- (trt == 0)
     oracle.results[[t]][11] <- sum(y.cur[sub.0x] * weights.cur[sub.0x]) /
         sum(weights.cur[sub.0x])
}
mean(unlist(lapply(1:periods, function(i)
    oracle.results[[i]] <= CIs[[i]][2,] & oracle.results[[i]] >= CIs[[i]][1,])))

}
